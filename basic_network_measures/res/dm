#!/usr/bin/python
import argparse
import os, sys

class bc:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'


ignore = ['dm', 'checked.txt', 'unchecked.txt', 'gitfiles']


CONFLICT = 'CONFLICT'
experiment_types = ["ip_bw_ib","ip_bw_eth","ip_lat_ib","ip_lat_eth",
    "rdma_bw_r","rdma_bw_w","rdma_bw_s",
    "rdma_lat_r","rdma_lat_w","rdma_lat_s"]

def list_checked(unchecked=False):
    experiments_checked = dict(zip( experiment_types, [None] * len(experiment_types) ))
    tobeadded = list()      # correctly formatted checked file, no conflict, ready to be added to repo
    wrongnames = list()     # checked files with names that do not follow convention
    redundants = list()     # multiple checked files of the same experiment type
    tracked_files = list()  # all tracked files in the directory (except ignored)
    ready_plot= list()      # tracked files with no error
    unchecked_files = list()# unchecked files (except ignored)
    checked_files = list()  # checked files (except ignored)



    print bc.OKBLUE+ "> listing all checked files" + bc.ENDC + '\n'


    # GET CHECKED
    os.system('grep -l "#CHECKED" * > checked.txt')
    with open('checked.txt') as checked:
        for filename in checked:
            fn = filename.strip()
            if fn in ignore:
                continue
            checked_files.append(fn)
    # GET UNCHECKED
    os.system('grep -L "#CHECKED" * > unchecked.txt')
    with open('unchecked.txt') as unchecked:
        for filename in unchecked:
            fn = filename.strip()
            if fn in ignore:
                continue
            unchecked_files.append(fn)
    # GET TRACKED FILES
    os.system('git ls-files > gitfiles.txt')
    with open('gitfiles.txt') as gitfiles:
        for filename in gitfiles:
            fn = filename.strip()
            if fn in ignore:
                continue
            tracked_files.append(fn)


    # PRINT CHECKED FILES
    print "[ ALL MARKED FILES ]"
    if not len(checked_files):
        print bc.OKGREEN + "NONE" + bc.ENDC
    else:
        for f in checked_files:
            print f
    print ""

    # PRINT UNCHECKED FILES
    print "[ ALL UNMARKED FILES ]"
    if not len(unchecked_files):
        print bc.OKGREEN + "NONE" + bc.ENDC
    else:
        for f in unchecked_files:
            print f
    print ""

    # PRINT ERRORS WITH CHECKED FILES
    print "[ ERRORS ]"
    for fn in checked_files:
        ex_type = get_exp_type(fn)
        
        # DATA FILES SHOULD BE PREFIXED BY THEIR EXPERIMENT TYPE
        if ex_type not in experiment_types:
            print bc.FAIL + fn + bc.WARNING + ': filename does not follow naming convention' + bc.ENDC
            wrongnames.append(fn)
            continue
        
        # THERE SHOULD BE NO MORE THAN ONE CHECKED DATA FILE FOR ANY EXPERIEMTN TYPE
        curr = experiments_checked[ex_type] 
        if curr == None:
            experiments_checked[ex_type] = fn
        elif curr != CONFLICT: # conflict first detected
            print bc.FAIL + fn + bc.WARNING + ': conflict with ' + curr + bc.ENDC
            redundants.extend((curr, fn))
            experiments_checked[ex_type] = CONFLICT
        else: # curr is CONFLICT
            print bc.FAIL + fn + bc.WARNING + ': conflict' + bc.ENDC
            redundants.append(fn)

    print ""
    print "[ REPORT ]" 

    
    # SUMMARY OF COMPLYING DATA FILES AND CONFLICTS (ALSO SHOW WHICH ONES ARE IN THE REPO)
    for exp_type in experiments_checked:
        filename = experiments_checked[exp_type]

        if filename == CONFLICT:
            desc = bc.WARNING + filename + bc.ENDC
        elif filename == None:
            desc = bc.FAIL + "No file" + bc.ENDC
        else:
            desc = bc.OKGREEN + filename + bc.ENDC
            
            # CHECK IF IN REPO
            if filename in tracked_files: 
                desc += bc.OKBLUE + ' (tracked) ' + bc.ENDC
                ready_plot.append(filename)
            else: 
                desc += bc.OKBLUE+ ' (not tracked) ' + bc.ENDC
                tobeadded.append(filename)
        print exp_type + "\t -> \t" + desc

    os.system('rm checked.txt')
    os.system('rm unchecked.txt')
    os.system('rm gitfiles.txt')


    """
    with open('checked.txt') as checked:
        print ""
        print "[ ERRORS ]" 
        for filename in checked:
            fn = filename.strip()

            if fn == 'dm': 
                continue

            if ex_type not in experiment_types:
                print bc.FAIL + fn + bc.WARNING + ': filename does not follow naming convention' + bc.ENDC
                wrongnames.append(fn)
                continue

            # THERE SHOULD BE NO MORE THAN ONE CHECKED DATA FILE FOR ANY EXPERIEMTN TYPE
            curr = experiments_checked[ex_type] 

            if curr == None:
                experiments_checked[ex_type] = fn
            elif curr != CONFLICT: # conflict first detected
                print bc.FAIL + fn + bc.WARNING + ': conflict with ' + curr + bc.ENDC
                redundants.extend((curr, fn))
                experiments_checked[ex_type] = CONFLICT
            else: # curr is CONFLICT
                print bc.FAIL + fn + bc.WARNING + ': conflict' + bc.ENDC
                redundants.append(fn)

                """


    print ""

    return (tobeadded, wrongnames, redundants, tracked_files, unchecked_files, checked_files, ready_plot)

def query_yes_no(question, default="yes"):
    """Ask a yes/no question via raw_input() and return their answer.

    "question" is a string that is presented to the user.
    "default" is the presumed answer if the user just hits <Enter>.
        It must be "yes" (the default), "no" or None (meaning
        an answer is required of the user).

    The "answer" return value is True for "yes" or False for "no".
    """
    valid = {"yes": True, "y": True, "ye": True,
             "no": False, "n": False}
    if default is None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("invalid default answer: '%s'" % default)

    while True:
        sys.stdout.write(question + prompt)
        choice = raw_input().lower()
        if default is not None and choice == '':
            return valid[default]
        elif choice in valid:
            return valid[choice]
        else:
            sys.stdout.write("Please respond with 'yes' or 'no' "
                             "(or 'y' or 'n').\n")

def get_exp_type(filename):
    return '_'.join(filename.split('_')[:3])

def plotdata(datafile, outfile):
    pass

# MAIN!


parser = argparse.ArgumentParser()
group = parser.add_mutually_exclusive_group()
group.add_argument('-l', '--list', action='store_true')
group.add_argument('-a', '--add', action='store_true')
group.add_argument('-c', '--clean', action='store_true')
group.add_argument('-s', '--smash', action='store_true')
group.add_argument('-r', '--reset', action='store_true')
group.add_argument('-p', '--plot', action='store_true')
args = parser.parse_args()

if args.list:
    list_checked()

elif args.add:
    # commit "green" ones that are not currently tracked
    (tobeadded, wrongnames, redundants, tracked_files, unchecked_files, checked_files, ready_plot) = list_checked()

    if not len(tobeadded):
        print bc.FAIL + "no files to be added" + bc.ENDC
        sys.exit()


    print "following files will be added to git repo:"
    for f in tobeadded:
        print '\t' + bc.BOLD + f + bc.ENDC

    if not query_yes_no("good?"): sys.exit()

    for f in tobeadded:
        os.system('git add ' + f)

elif args.smash:
    # delete "wrong" files -- wrong names, redundant ones
    (tobeadded, wrongnames, redundants, tracked_files, unchecked_files, checked_files, ready_plot) = list_checked()

    tbd = wrongnames + redundant

    if not len(tbd):
        print bc.FAIL + "no files to be deleted" + bc.ENDC
        sys.exit()

    print "following files will be removed from directory:"
    for f in tbd:
        print '\t' + bc.BOLD + f + bc.ENDC

    if not query_yes_no("good?"): sys.exit()

    for f in tbd:
        if f in tracked_files:
            os.system('git rm ' + f)
        else:
            os.system('rm ' + f)

elif args.clean:
    # remove all unchecked files using rm
    (tobeadded, wrongnames, redundants, tracked_files, unchecked_files, checked_files, ready_plot) = list_checked()

    if not len(unchecked_files):
        print bc.FAIL + "no files to be deleted" + bc.ENDC
        sys.exit()

    print "following files will be removed from directory:"
    for f in unchecked_files:
        print '\t' + bc.BOLD + f + bc.ENDC

    if not query_yes_no("good?"): sys.exit()

    for f in unchecked_files:
        os.remove(f)

elif args.reset:
    # remove everything (except for dm, of course)
    (tobeadded, wrongnames, redundants, tracked_files, unchecked_files, checked_files, ready_plot) = list_checked()
    allfiles = unchecked_files + checked_files
    if not len(allfiles):
        print bc.FAIL + "no files to be deleted" + bc.ENDC
        sys.exit()

    print "following files will be removed from directory:"
    for f in allfiles:
        print '\t' + bc.BOLD + f + bc.ENDC

    if not query_yes_no("good?"): sys.exit()

    for f in allfiles:
        os.remove(f)

elif args.plot:
    # plot ready_plot
    (tobeadded, wrongnames, redundants, tracked_files, unchecked_files, checked_files, ready_plot) = list_checked()

    if not len(allfiles):
        print bc.FAIL + "no files to be plotted" + bc.ENDC
        sys.exit()

    print "following files will be plotted: <original> ---> <plot destination>"
    for f in ready_plot:
        ex_type = get_exp_type(f)
        print '\t' + bc.BOLD + f + ' ---> ' + ex_type + '.png'+ bc.ENDC

    if not query_yes_no("good?"): sys.exit()

    # now actually plot (what if one of them fails?)

else:
    print "no op"




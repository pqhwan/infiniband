#!/usr/bin/python
import argparse
import os, sys

class bc:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'


CONFLICT = 'CONFLICT'
experiment_types = ["ip_bw_ib","ip_bw_eth","ip_lat_ib","ip_lat_eth",
    "rdma_bw_r","rdma_bw_w","rdma_bw_s",
    "rdma_lat_r","rdma_lat_w","rdma_lat_s"]

def list_checked(unchecked=False):
    experiments_checked = dict(zip( experiment_types, [None] * len(experiment_types) ))
    tobeadded = list()
    tracked = list()
    greenones = list()
    wrongnames = list()
    redundants = list()
    tracked_files = list()

    print bc.OKBLUE+ "> listing all checked files" + bc.ENDC + '\n'

    os.system('grep -l "#CHECKED" * > checked.txt')
    os.system('git ls-files > gitfiles.txt')

    with open('gitfiles.txt') as gitfiles:
        for filename in gitfiles:
            tracked_files.append(filename.strip())


    print "[ ERRORS ]" 

    with open('checked.txt') as checked:
        for filename in checked:
            fn = filename.strip()

            if fn == 'dm' or fn == 'dm_py': 
                continue

            ex_type = '_'.join(fn.split('_')[:3])

            if ex_type not in experiment_types:
                print bc.FAIL + fn + bc.WARNING + ': filename does not follow nomenclature' + bc.ENDC
                wrongnames.append(fn)
                continue

            current = experiments_checked[ex_type] 

            if current != None:
                print bc.FAIL + fn + bc.WARNING + ': redundant checked file of the ' + \
                'same experiment type' + bc.ENDC

                if current != CONFLICT:
                    redundants.append(current)
                redundants.append(fn)
                experiments_checked[ex_type] = CONFLICT

            experiments_checked[ex_type] = fn

    print ""
    
    print "[ REPORT ]" 

    for exp in experiments_checked:
        curr = experiments_checked[exp] 
        if curr == CONFLICT:
            desc = bc.WARNING + curr + bc.ENDC
        elif curr != None:
            desc = bc.OKGREEN + curr + bc.ENDC
            greenones.append(curr)
            if curr in tracked_files: 
                desc += bc.OKBLUE + ' (tracked) ' + bc.ENDC
                tracked.append(curr)
            else: 
                desc += bc.OKBLUE+ ' (not tracked) ' + bc.ENDC
                tobeadded.append(curr)
        else:
            desc = bc.FAIL+"No file"+bc.ENDC
        print exp + "\t -> \t" + desc

    os.system('rm checked.txt')
    os.system('rm gitfiles.txt')

    print ""

    return (tobeadded,greenones,wrongnames,redundants,tracked_files)

def add_checked():
    pass
def delete_checked():
    pass
def query_yes_no(question, default="yes"):
    """Ask a yes/no question via raw_input() and return their answer.

    "question" is a string that is presented to the user.
    "default" is the presumed answer if the user just hits <Enter>.
        It must be "yes" (the default), "no" or None (meaning
        an answer is required of the user).

    The "answer" return value is True for "yes" or False for "no".
    """
    valid = {"yes": True, "y": True, "ye": True,
             "no": False, "n": False}
    if default is None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("invalid default answer: '%s'" % default)

    while True:
        sys.stdout.write(question + prompt)
        choice = raw_input().lower()
        if default is not None and choice == '':
            return valid[default]
        elif choice in valid:
            return valid[choice]
        else:
            sys.stdout.write("Please respond with 'yes' or 'no' "
                             "(or 'y' or 'n').\n")


parser = argparse.ArgumentParser()
group = parser.add_mutually_exclusive_group()
group.add_argument('-l', '--list', action='store_true')
group.add_argument('-a', '--add', action='store_true')
group.add_argument('-d', '--delete', action='store_true')
args = parser.parse_args()

if args.list:
    list_checked()
elif args.add:
    # commit "green" ones that are not currently tracked
    (tba, greens, w, r, t) = list_checked()

    print "following files will be added to git repo:"
    for f in tba:
        print '\t' + bc.BOLD + f + bc.ENDC

    if not query_yes_no("good?"): sys.exit()

    for f in tba:
        os.system('git add ' + tbc)

    print bc.OKBLUE+"> "
elif args.delete:
    # delete files that are not one of the "green" ones
    ( t, g, wrongname, redundant, tracked ) = list_checked()

    print "following files will be removed from directory:"
    for f in wrongname + redundant:
        print '\t' + bc.BOLD + f + bc.ENDC

    print tracked

    if not query_yes_no("good?"): sys.exit()

    for f in wrongname + redundant:
        if f in tracked:
            print bc.FAIL + "skipping " + f + " (tracked by git -- too hot for me)" + bc.ENDC
        else:
            os.system('rm ' + f)


else:
    print "no op"



